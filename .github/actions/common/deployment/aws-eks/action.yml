name: Deploy to AWS EKS
description: 'Deploy application to AWS EKS cluster using Helm with direct GHCR image pull'

inputs:
  app-name:
    description: 'Name of the application to deploy'
    required: true
  tag:
    description: 'Docker image tag'
    required: true
  chart-path:
    description: 'Path to the Helm chart'
    required: true
  repository:
    description: 'Docker image repository (e.g., ghcr.io/org/app)'
    required: true
  namespace:
    description: 'Kubernetes namespace'
    required: false
    default: 'default'
  region:
    description: 'AWS region'
    required: true
  cluster-name:
    description: 'EKS cluster name'
    required: true
  aws-access-key-id:
    description: 'AWS Access Key ID'
    required: false
  aws-secret-access-key:
    description: 'AWS Secret Access Key'
    required: false
  aws-session-token:
    description: 'AWS Session Token'
    required: false
  ghcr-username:
    description: 'GitHub Container Registry username'
    required: false
  ghcr-pat:
    description: 'GitHub Container Registry Personal Access Token'
    required: false

runs:
  using: composite
  steps:
    # Set up kubectl
    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: v1.29.0

    # Set up Helm
    - name: Set up Helm
      uses: azure/setup-helm@v3
      with:
        version: v3.14.0

    # Configure AWS credentials and update kubeconfig
    - name: Configure AWS and EKS access
      run: |
        # Set AWS credentials
        export AWS_ACCESS_KEY_ID=${{ inputs.aws-access-key-id }}
        export AWS_SECRET_ACCESS_KEY=${{ inputs.aws-secret-access-key }}
        if [[ -n "${{ inputs.aws-session-token }}" ]]; then
          export AWS_SESSION_TOKEN=${{ inputs.aws-session-token }}
        fi
        
        # Verify AWS credentials
        echo "=== AWS Identity ==="
        aws sts get-caller-identity
        
        # Check EKS cluster status
        echo "=== EKS Cluster Status ==="
        aws eks describe-cluster --region ${{ inputs.region }} --name ${{ inputs.cluster-name }} --query 'cluster.status'
        
        # Update kubeconfig for EKS cluster
        echo "=== Updating kubeconfig ==="
        aws eks update-kubeconfig --region ${{ inputs.region }} --name ${{ inputs.cluster-name }}
        
        # Try to access cluster with more debugging
        echo "=== Testing cluster access ==="
        kubectl cluster-info || echo "Failed to get cluster info"
        kubectl get nodes || echo "Failed to get nodes"
        
        # Check if we can list namespaces
        echo "=== Testing namespace access ==="
        kubectl get namespaces || echo "Failed to get namespaces"
        
        # Check EKS cluster authentication
        echo "=== EKS Authentication Debug ==="
        aws eks get-token --cluster-name ${{ inputs.cluster-name }} --region ${{ inputs.region }} || echo "Failed to get EKS token"
      shell: bash

    # Create namespace and GHCR secret
    - name: Create namespace and GHCR secret
      if: inputs.ghcr-username != '' && inputs.ghcr-pat != ''
      shell: bash
      run: |
        # Set AWS credentials
        export AWS_ACCESS_KEY_ID=${{ inputs.aws-access-key-id }}
        export AWS_SECRET_ACCESS_KEY=${{ inputs.aws-secret-access-key }}
        if [[ -n "${{ inputs.aws-session-token }}" ]]; then
          export AWS_SESSION_TOKEN=${{ inputs.aws-session-token }}
        fi
        
        # Create namespace if it doesn't exist
        kubectl create namespace ${{ inputs.namespace }} --dry-run=client -o yaml | kubectl apply -f -
        
        # Create GHCR secret
        kubectl create secret docker-registry ghcr-secret \
          --docker-server=ghcr.io \
          --docker-username=${{ inputs.ghcr-username }} \
          --docker-password=${{ inputs.ghcr-pat }} \
          --namespace=${{ inputs.namespace }} \
          --dry-run=client -o yaml | kubectl apply -f -

    # Deploy via Helm
    - name: Deploy via Helm
      shell: bash
      run: |
        # Set AWS credentials
        export AWS_ACCESS_KEY_ID=${{ inputs.aws-access-key-id }}
        export AWS_SECRET_ACCESS_KEY=${{ inputs.aws-secret-access-key }}
        if [[ -n "${{ inputs.aws-session-token }}" ]]; then
          export AWS_SESSION_TOKEN=${{ inputs.aws-session-token }}
        fi
        
        helm upgrade --install ${{ inputs.app-name }} ${{ inputs.chart-path }} \
          --namespace ${{ inputs.namespace }} \
          --create-namespace \
          --set image.repository=${{ inputs.repository }} \
          --set image.tag=${{ inputs.tag }} \
          ${{ inputs.ghcr-username != '' && inputs.ghcr-pat != '' && '--set imagePullSecrets[0].name=ghcr-secret' || '' }}

    # Verify deployment
    - name: Verify deployment
      run: |
        # Set AWS credentials
        export AWS_ACCESS_KEY_ID=${{ inputs.aws-access-key-id }}
        export AWS_SECRET_ACCESS_KEY=${{ inputs.aws-secret-access-key }}
        if [[ -n "${{ inputs.aws-session-token }}" ]]; then
          export AWS_SESSION_TOKEN=${{ inputs.aws-session-token }}
        fi
        
        echo "Checking deployment status..."
        kubectl get pods -n ${{ inputs.namespace }} -l app.kubernetes.io/name=${{ inputs.app-name }}
        kubectl get services -n ${{ inputs.namespace }} -l app.kubernetes.io/name=${{ inputs.app-name }}
        
        # Wait for pods to be ready
        kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=${{ inputs.app-name }} -n ${{ inputs.namespace }} --timeout=300s
      shell: bash

    # Generate deployment summary
    - name: Generate deployment summary
      run: |
        # Set AWS credentials
        export AWS_ACCESS_KEY_ID=${{ inputs.aws-access-key-id }}
        export AWS_SECRET_ACCESS_KEY=${{ inputs.aws-secret-access-key }}
        if [[ -n "${{ inputs.aws-session-token }}" ]]; then
          export AWS_SESSION_TOKEN=${{ inputs.aws-session-token }}
        fi
        
        echo "## ðŸš€ AWS EKS Deployment Report" > deployment-summary.md
        
        # Get deployment status
        PODS=$(kubectl get pods -n ${{ inputs.namespace }} -l app.kubernetes.io/name=${{ inputs.app-name }} --no-headers | wc -l)
        READY_PODS=$(kubectl get pods -n ${{ inputs.namespace }} -l app.kubernetes.io/name=${{ inputs.app-name }} --no-headers | grep -c "Running")
        
        echo "- âœ… Deployment completed successfully" >> deployment-summary.md
        echo "- ðŸ“¦ Release: ${{ inputs.app-name }}" >> deployment-summary.md
        echo "- ðŸ·ï¸ Namespace: ${{ inputs.namespace }}" >> deployment-summary.md
        echo "- ðŸ³ Image: ${{ inputs.repository }}:${{ inputs.tag }}" >> deployment-summary.md
        echo "- ðŸŒ Region: ${{ inputs.region }}" >> deployment-summary.md
        echo "- ðŸ“Š Pods: $READY_PODS/$PODS ready" >> deployment-summary.md
        
        # Get service details
        SERVICE_IP=$(kubectl get service -n ${{ inputs.namespace }} -l app.kubernetes.io/name=${{ inputs.app-name }} -o jsonpath='{.items[0].spec.clusterIP}' 2>/dev/null || echo "N/A")
        SERVICE_PORT=$(kubectl get service -n ${{ inputs.namespace }} -l app.kubernetes.io/name=${{ inputs.app-name }} -o jsonpath='{.items[0].spec.ports[0].port}' 2>/dev/null || echo "N/A")
        
        if [[ "$SERVICE_IP" != "N/A" ]]; then
          echo "- ðŸ”— Service: $SERVICE_IP:$SERVICE_PORT" >> deployment-summary.md
        fi
        
        # Write to GITHUB_STEP_SUMMARY
        cat deployment-summary.md >> $GITHUB_STEP_SUMMARY
      shell: bash 
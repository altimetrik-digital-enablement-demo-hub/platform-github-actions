name: Deploy to AWS EKS
description: 'Deploy application to AWS EKS cluster using Helm with direct GHCR image pull'

inputs:
  app-name:
    description: 'Name of the application to deploy'
    required: true
  tag:
    description: 'Docker image tag'
    required: true
  chart-path:
    description: 'Path to the Helm chart'
    required: true
  repository:
    description: 'Docker image repository (e.g., ghcr.io/org/app)'
    required: true
  namespace:
    description: 'Kubernetes namespace'
    required: false
    default: 'default'
  region:
    description: 'AWS region'
    required: true
  cluster-name:
    description: 'EKS cluster name'
    required: true
  aws-access-key-id:
    description: 'AWS Access Key ID'
    required: false
  aws-secret-access-key:
    description: 'AWS Secret Access Key'
    required: false
  aws-session-token:
    description: 'AWS Session Token'
    required: false
  ghcr-username:
    description: 'GitHub Container Registry username'
    required: false
  ghcr-pat:
    description: 'GitHub Container Registry Personal Access Token'
    required: false
  service-type:
    description: 'Kubernetes service type (ClusterIP, LoadBalancer, NodePort)'
    required: false
    default: 'LoadBalancer'

runs:
  using: composite
  steps:
    # Set up kubectl
    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: v1.29.0

    # Set up Helm
    - name: Set up Helm
      uses: azure/setup-helm@v3
      with:
        version: v3.14.0

    # Configure AWS credentials and update kubeconfig
    - name: Configure AWS and EKS access
      run: |
        # Set AWS credentials
        export AWS_ACCESS_KEY_ID=${{ inputs.aws-access-key-id }}
        export AWS_SECRET_ACCESS_KEY=${{ inputs.aws-secret-access-key }}
        if [[ -n "${{ inputs.aws-session-token }}" ]]; then
          export AWS_SESSION_TOKEN=${{ inputs.aws-session-token }}
        fi
        
        # Verify AWS credentials
        echo "=== AWS Identity ==="
        aws sts get-caller-identity
        
        # Check EKS cluster status
        echo "=== EKS Cluster Status ==="
        aws eks describe-cluster --region ${{ inputs.region }} --name ${{ inputs.cluster-name }} --query 'cluster.status'
        
        # Update kubeconfig for EKS cluster
        echo "=== Updating kubeconfig ==="
        aws eks update-kubeconfig --region ${{ inputs.region }} --name ${{ inputs.cluster-name }}
        
        # Test cluster access
        echo "=== Testing cluster access ==="
        kubectl cluster-info
        kubectl get nodes
      shell: bash

    # Create namespace and GHCR secret
    - name: Create namespace and GHCR secret
      if: inputs.ghcr-username != '' && inputs.ghcr-pat != ''
      shell: bash
      run: |
        # Set AWS credentials
        export AWS_ACCESS_KEY_ID=${{ inputs.aws-access-key-id }}
        export AWS_SECRET_ACCESS_KEY=${{ inputs.aws-secret-access-key }}
        if [[ -n "${{ inputs.aws-session-token }}" ]]; then
          export AWS_SESSION_TOKEN=${{ inputs.aws-session-token }}
        fi
        
        # Create namespace if it doesn't exist
        kubectl create namespace ${{ inputs.namespace }} --dry-run=client -o yaml | kubectl apply -f -
        
        # Create GHCR secret
        kubectl create secret docker-registry ghcr-secret \
          --docker-server=ghcr.io \
          --docker-username=${{ inputs.ghcr-username }} \
          --docker-password=${{ inputs.ghcr-pat }} \
          --namespace=${{ inputs.namespace }} \
          --dry-run=client -o yaml | kubectl apply -f -

    # Deploy via Helm
    - name: Deploy via Helm
      shell: bash
      run: |
        # Set AWS credentials
        export AWS_ACCESS_KEY_ID=${{ inputs.aws-access-key-id }}
        export AWS_SECRET_ACCESS_KEY=${{ inputs.aws-secret-access-key }}
        if [[ -n "${{ inputs.aws-session-token }}" ]]; then
          export AWS_SESSION_TOKEN=${{ inputs.aws-session-token }}
        fi
        
        # Build Helm command
        HELM_CMD="helm upgrade --install ${{ inputs.app-name }} ${{ inputs.chart-path }}"
        HELM_CMD="$HELM_CMD --namespace ${{ inputs.namespace }}"
        HELM_CMD="$HELM_CMD --create-namespace"
        HELM_CMD="$HELM_CMD --set image.repository=${{ inputs.repository }}"
        HELM_CMD="$HELM_CMD --set image.tag=${{ inputs.tag }}"
        HELM_CMD="$HELM_CMD --set service.type=${{ inputs.service-type }}"
        
        # Add image pull secrets if provided
        if [[ -n "${{ inputs.ghcr-username }}" && -n "${{ inputs.ghcr-pat }}" ]]; then
          HELM_CMD="$HELM_CMD --set imagePullSecrets[0].name=ghcr-secret"
        fi
        
        echo "Executing: $HELM_CMD"
        eval $HELM_CMD

    # Verify deployment
    - name: Verify deployment
      run: |
        # Set AWS credentials
        export AWS_ACCESS_KEY_ID=${{ inputs.aws-access-key-id }}
        export AWS_SECRET_ACCESS_KEY=${{ inputs.aws-secret-access-key }}
        if [[ -n "${{ inputs.aws-session-token }}" ]]; then
          export AWS_SESSION_TOKEN=${{ inputs.aws-session-token }}
        fi
        
        echo "Checking deployment status..."
        kubectl get pods -n ${{ inputs.namespace }} -l app.kubernetes.io/name=${{ inputs.app-name }}
        kubectl get services -n ${{ inputs.namespace }} -l app.kubernetes.io/name=${{ inputs.app-name }}
        
        # Wait for pods to be ready
        kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=${{ inputs.app-name }} -n ${{ inputs.namespace }} --timeout=300s
      shell: bash

    # Generate deployment summary
    - name: Generate deployment summary
      run: |
        # Set AWS credentials
        export AWS_ACCESS_KEY_ID=${{ inputs.aws-access-key-id }}
        export AWS_SECRET_ACCESS_KEY=${{ inputs.aws-secret-access-key }}
        if [[ -n "${{ inputs.aws-session-token }}" ]]; then
          export AWS_SESSION_TOKEN=${{ inputs.aws-session-token }}
        fi
        
        echo "## üöÄ AWS EKS Deployment Report" > deployment-summary.md
        
        # Get deployment status
        PODS=$(kubectl get pods -n ${{ inputs.namespace }} -l app.kubernetes.io/name=${{ inputs.app-name }} --no-headers | wc -l)
        READY_PODS=$(kubectl get pods -n ${{ inputs.namespace }} -l app.kubernetes.io/name=${{ inputs.app-name }} --no-headers | grep -c "Running")
        
        echo "- ‚úÖ Deployment completed successfully" >> deployment-summary.md
        echo "- üì¶ Release: ${{ inputs.app-name }}" >> deployment-summary.md
        echo "- üè∑Ô∏è Namespace: ${{ inputs.namespace }}" >> deployment-summary.md
        echo "- üê≥ Image: ${{ inputs.repository }}:${{ inputs.tag }}" >> deployment-summary.md
        echo "- üåç Region: ${{ inputs.region }}" >> deployment-summary.md
        echo "- üìä Pods: $READY_PODS/$PODS ready" >> deployment-summary.md
        
        # Get service details
        SERVICE_TYPE=$(kubectl get service -n ${{ inputs.namespace }} -l app.kubernetes.io/name=${{ inputs.app-name }} -o jsonpath='{.items[0].spec.type}' 2>/dev/null || echo "N/A")
        SERVICE_PORT=$(kubectl get service -n ${{ inputs.namespace }} -l app.kubernetes.io/name=${{ inputs.app-name }} -o jsonpath='{.items[0].spec.ports[0].port}' 2>/dev/null || echo "N/A")
        
        # Wait for LoadBalancer to get external IP
        if [[ "$SERVICE_TYPE" == "LoadBalancer" ]]; then
          echo "Waiting for LoadBalancer to get external IP..."
          
          # Try to get external IP with retries
          echo "Checking for external IP..."
          for i in {1..10}; do
            EXTERNAL_HOSTNAME=$(kubectl get service -n ${{ inputs.namespace }} -l app.kubernetes.io/name=${{ inputs.app-name }} -o jsonpath='{.items[0].status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "N/A")
            EXTERNAL_IP=$(kubectl get service -n ${{ inputs.namespace }} -l app.kubernetes.io/name=${{ inputs.app-name }} -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "N/A")
            
            if [[ "$EXTERNAL_HOSTNAME" != "N/A" && "$EXTERNAL_HOSTNAME" != "<pending>" ]]; then
              echo "‚úÖ External hostname found: $EXTERNAL_HOSTNAME"
              
              # Extract LoadBalancer name from hostname
              LB_NAME=$(echo "$EXTERNAL_HOSTNAME" | cut -d'.' -f1)
              echo "üîç Looking up LoadBalancer: $LB_NAME"
              
              # Get LoadBalancer details from AWS
              LB_ARN=$(aws elbv2 describe-load-balancers --region ${{ inputs.region }} --query "LoadBalancers[?contains(LoadBalancerName, '$LB_NAME')].LoadBalancerArn" --output text 2>/dev/null)
              
              if [[ -n "$LB_ARN" && "$LB_ARN" != "None" ]]; then
                echo "‚úÖ LoadBalancer found in AWS: $LB_ARN"
                
                # Get LoadBalancer state
                LB_STATE=$(aws elbv2 describe-load-balancers --load-balancer-arns "$LB_ARN" --region ${{ inputs.region }} --query 'LoadBalancers[0].State.Code' --output text 2>/dev/null)
                
                if [[ "$LB_STATE" == "active" ]]; then
                  echo "‚úÖ LoadBalancer is active"
                  echo "- üåê External URL: http://$EXTERNAL_HOSTNAME:$SERVICE_PORT" >> deployment-summary.md
                  echo "- üåê Health Check: http://$EXTERNAL_HOSTNAME:$SERVICE_PORT/actuator/health" >> deployment-summary.md
                  echo "- ‚è≥ Note: DNS may take a few minutes to propagate. If URL doesn't work, try again in 2-3 minutes." >> deployment-summary.md
                else
                  echo "‚è≥ LoadBalancer state: $LB_STATE"
                  echo "- üåê External URL: http://$EXTERNAL_HOSTNAME:$SERVICE_PORT" >> deployment-summary.md
                  echo "- üåê Health Check: http://$EXTERNAL_HOSTNAME:$SERVICE_PORT/actuator/health" >> deployment-summary.md
                  echo "- ‚è≥ Note: LoadBalancer is still provisioning. Please wait a few minutes." >> deployment-summary.md
                fi
              else
                echo "‚è≥ LoadBalancer not yet available in AWS"
                echo "- üåê External URL: http://$EXTERNAL_HOSTNAME:$SERVICE_PORT" >> deployment-summary.md
                echo "- üåê Health Check: http://$EXTERNAL_HOSTNAME:$SERVICE_PORT/actuator/health" >> deployment-summary.md
                echo "- ‚è≥ Note: LoadBalancer is being created. Please wait a few minutes." >> deployment-summary.md
              fi
              break
            elif [[ "$EXTERNAL_IP" != "N/A" && "$EXTERNAL_IP" != "<pending>" ]]; then
              echo "‚úÖ External IP found: $EXTERNAL_IP"
              echo "- üåê External URL: http://$EXTERNAL_IP:$SERVICE_PORT" >> deployment-summary.md
              echo "- üåê Health Check: http://$EXTERNAL_IP:$SERVICE_PORT/actuator/health" >> deployment-summary.md
              break
            else
              echo "‚è≥ Attempt $i/10: External IP not yet available, waiting 30 seconds..."
              sleep 30
            fi
          done
          
          if [[ "$EXTERNAL_HOSTNAME" == "N/A" || "$EXTERNAL_HOSTNAME" == "<pending>" ]] && [[ "$EXTERNAL_IP" == "N/A" || "$EXTERNAL_IP" == "<pending>" ]]; then
            echo "- ‚è≥ LoadBalancer IP pending..." >> deployment-summary.md
            echo "- üí° Check manually: kubectl get service -n ${{ inputs.namespace }}" >> deployment-summary.md
          fi
        elif [[ "$SERVICE_TYPE" == "NodePort" ]]; then
          NODEPORT=$(kubectl get service -n ${{ inputs.namespace }} -l app.kubernetes.io/name=${{ inputs.app-name }} -o jsonpath='{.items[0].spec.ports[0].nodePort}' 2>/dev/null || echo "N/A")
          if [[ "$NODEPORT" != "N/A" ]]; then
            echo "- üîó NodePort: $NODEPORT" >> deployment-summary.md
          fi
        else
          SERVICE_IP=$(kubectl get service -n ${{ inputs.namespace }} -l app.kubernetes.io/name=${{ inputs.app-name }} -o jsonpath='{.items[0].spec.clusterIP}' 2>/dev/null || echo "N/A")
          if [[ "$SERVICE_IP" != "N/A" ]]; then
            echo "- üîó Internal Service: $SERVICE_IP:$SERVICE_PORT" >> deployment-summary.md
          fi
        fi
        
        # Write to GITHUB_STEP_SUMMARY
        cat deployment-summary.md >> $GITHUB_STEP_SUMMARY
      shell: bash 
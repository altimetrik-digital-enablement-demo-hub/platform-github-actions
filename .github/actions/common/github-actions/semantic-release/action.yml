name: Semantic Release
description: 'Create semantic GitHub releases with automatic version calculation and CHANGELOG generation'

inputs:
  token:
    description: 'GitHub token for authentication'
    required: true

  version-bump:
    description: 'Version bump type (auto, major, minor, patch)'
    required: false
    default: 'auto'

  manual-version:
    description: 'Manual version (e.g., 1.2.3) - overrides version-bump'
    required: false

  release-notes:
    description: 'Additional release notes to append to the CHANGELOG'
    required: false

  draft:
    description: 'Create release as draft'
    required: false
    default: 'false'

  prerelease:
    description: 'Create release as prerelease'
    required: false
    default: 'false'

outputs:
  tag:
    description: "The new semantic version tag"
    value: ${{ steps.semantic-release.outputs.tag }}
  
  version:
    description: "The version number without 'v' prefix"
    value: ${{ steps.semantic-release.outputs.version }}

runs:
  using: 'composite'
  steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Git
      shell: bash
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

    - name: Semantic Release
      id: semantic-release
      shell: bash
      run: |
        # Validate manual version if provided
        if [ -n "${{ inputs.manual-version }}" ]; then
          if [[ ! "${{ inputs.manual-version }}" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?(\+[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?$ ]]; then
            echo "Error: Manual version '${{ inputs.manual-version }}' does not comply with semantic versioning"
            exit 1
          fi
          echo "Using manual version: ${{ inputs.manual-version }}"
          NEW_VERSION="${{ inputs.manual-version }}"
          NEW_TAG="v${{ inputs.manual-version }}"
        else
          # Get current version from git tags
          git fetch --tags
          LATEST_TAG=$(git tag --sort=-v:refname | head -n 1)
          
          if [ -z "$LATEST_TAG" ]; then
            CURRENT_VERSION="0.0.0"
            RANGE=""
          else
            CURRENT_VERSION="${LATEST_TAG#v}"
            RANGE="$LATEST_TAG..HEAD"
          fi
          
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          
          # Determine version bump based on input
          case "${{ inputs.version-bump }}" in
            "auto")
              # Analyze commit messages for conventional commits
              COMMITS=$(git log $RANGE --pretty=format:"%s" 2>/dev/null || echo "")
              BUMP=""
              
              while IFS= read -r COMMIT; do
                LOWER=$(echo "$COMMIT" | tr '[:upper:]' '[:lower:]')
                if [[ "$LOWER" =~ (^|[^a-zA-Z0-9])(major|feat|fix|docs|style|refactor|perf|test|chore|build|ci|revert)([:[:space:]]|$) ]]; then
                  FIRST_KEYWORD="${BASH_REMATCH[2]}"
                  case "$FIRST_KEYWORD" in
                    major)
                      BUMP="major"
                      break
                      ;;
                    feat)
                      [[ "$BUMP" != "major" ]] && BUMP="minor"
                      ;;
                    fix|docs|style|refactor|perf|test|chore|build|ci)
                      [[ "$BUMP" != "major" && "$BUMP" != "minor" ]] && BUMP="patch"
                      ;;
                    revert)
                      [[ "$BUMP" != "major" && "$BUMP" != "minor" ]] && BUMP="patch"
                      ;;
                  esac
                fi
              done <<< "$COMMITS"
              
              if [ -z "$BUMP" ]; then
                echo "No valid semantic keyword found. Skipping release."
                echo "tag=" >> "$GITHUB_OUTPUT"
                echo "version=" >> "$GITHUB_OUTPUT"
                exit 0
              fi
              ;;
            "major")
              BUMP="major"
              ;;
            "minor")
              BUMP="minor"
              ;;
            "patch")
              BUMP="patch"
              ;;
            *)
              echo "Error: Invalid version-bump value '${{ inputs.version-bump }}'"
              exit 1
              ;;
          esac
          
          # Calculate new version
          case $BUMP in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          NEW_TAG="v$NEW_VERSION"
        fi
        
        # Generate CHANGELOG
        PREV_TAG="${LATEST_TAG:-initial commit}"
        REPO_URL="https://github.com/${{ github.repository }}"
        RELEASE_DATE=$(date -u +"%B %d, %Y")
        GIT_HASH=$(git rev-parse --short HEAD)
        
        # Create changelog content
        echo "## $NEW_TAG" > changelog.md
        echo "" >> changelog.md
        echo "**Release Date**: $RELEASE_DATE" >> changelog.md
        echo "**Commit**: \`$GIT_HASH\`" >> changelog.md
        echo "**Previous Version**: \`$PREV_TAG\`" >> changelog.md
        echo "" >> changelog.md
        echo "### Changes" >> changelog.md
        
        # Get commits since last tag
        if [ -n "$RANGE" ]; then
          COMMITS=$(git log $RANGE --pretty=format:"- %s (%h)" --reverse)
          if [ -n "$COMMITS" ]; then
            echo "" >> changelog.md
            echo "$COMMITS" >> changelog.md
          fi
        fi
        
        # Add full changelog link
        if [ -n "$LATEST_TAG" ]; then
          echo "" >> changelog.md
          echo "**Full Changelog**: [$NEW_TAG ... $PREV_TAG]($REPO_URL/compare/$LATEST_TAG...$NEW_TAG)" >> changelog.md
        fi
        
        # Add additional release notes if provided
        if [ -n "${{ inputs.release-notes }}" ]; then
          echo "" >> changelog.md
          echo "### Additional Notes" >> changelog.md
          echo "" >> changelog.md
          echo "${{ inputs.release-notes }}" >> changelog.md
        fi
        
        # Create git tag
        git tag "$NEW_TAG"
        git push origin "$NEW_TAG"
        
        # Create GitHub release
        DRAFT_FLAG=""
        if [ "${{ inputs.draft }}" = "true" ]; then
          DRAFT_FLAG="--draft"
        fi
        
        PRERELEASE_FLAG=""
        if [ "${{ inputs.prerelease }}" = "true" ]; then
          PRERELEASE_FLAG="--prerelease"
        fi
        
        # Create release using GitHub CLI
        gh release create "$NEW_TAG" \
          --title "Release $NEW_TAG" \
          --notes-file changelog.md \
          $DRAFT_FLAG \
          $PRERELEASE_FLAG
        
        # Set outputs
        echo "tag=$NEW_TAG" >> "$GITHUB_OUTPUT"
        echo "version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
        
        echo "Created release: $NEW_TAG"
        echo "Version: $NEW_VERSION" 
name: Semantic Release
description: 'Create semantic GitHub releases with automatic version calculation and CHANGELOG generation'

inputs:
  token:
    description: 'GitHub token for authentication'
    required: true

  version-bump:
    description: 'Version bump type (auto, major, minor, patch)'
    required: false
    default: 'auto'

  manual-version:
    description: 'Manual version (e.g., 1.2.3) - overrides version-bump'
    required: false

  release-notes:
    description: 'Additional release notes to append to the CHANGELOG'
    required: false

  draft:
    description: 'Create release as draft'
    required: false
    default: 'false'

  prerelease:
    description: 'Create release as prerelease'
    required: false
    default: 'false'

outputs:
  tag:
    description: "The new semantic version tag"
    value: ${{ steps.semantic-release.outputs.tag }}
  
  version:
    description: "The version number without 'v' prefix"
    value: ${{ steps.semantic-release.outputs.version }}

runs:
  using: 'composite'
  steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Git
      shell: bash
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

    - name: Semantic Release
      id: semantic-release
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
      run: |
        # Validate manual version if provided
        if [ -n "${{ inputs.manual-version }}" ]; then
          MANUAL_VERSION="${{ inputs.manual-version }}"
          # Simplified regex for semantic versioning validation
          if [[ ! "$MANUAL_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+ ]]; then
            echo "Error: Manual version '$MANUAL_VERSION' does not comply with semantic versioning"
            exit 1
          fi
          echo "Using manual version: $MANUAL_VERSION"
          NEW_VERSION="$MANUAL_VERSION"
          NEW_TAG="v$MANUAL_VERSION"
        else
          # Get current version from git tags (fetch once at the beginning)
          git fetch --tags
          LATEST_TAG=$(git tag --sort=-v:refname | head -n 1)
          
          if [ -z "$LATEST_TAG" ]; then
            CURRENT_VERSION="0.0.0"
            RANGE=""
          else
            CURRENT_VERSION="${LATEST_TAG#v}"
            RANGE="$LATEST_TAG..HEAD"
          fi
          
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          
          # Determine version bump based on input
          case "${{ inputs.version-bump }}" in
            "auto")
              # Analyze commit messages for conventional commits
              COMMITS=$(git log $RANGE --pretty=format:"%s" 2>/dev/null || echo "")
              BUMP=""
              
              while IFS= read -r COMMIT; do
                # Check for breaking changes in commit body
                COMMIT_BODY=$(git log --format=%B -n 1 "$COMMIT" 2>/dev/null || echo "")
                if [[ "$COMMIT_BODY" =~ BREAKING[[:space:]]CHANGE ]]; then
                  BUMP="major"
                  break
                fi
                
                # Check for breaking change shorthand (!) in commit message
                if [[ "$COMMIT" =~ ^[a-z]+(!|\([^)]*\)!): ]]; then
                  BUMP="major"
                  break
                fi
                
                # Check for conventional commit types
                LOWER=$(echo "$COMMIT" | tr '[:upper:]' '[:lower:]')
                if [[ "$LOWER" =~ ^(feat|fix|docs|style|refactor|perf|test|chore|build|ci|revert)([:[:space:]]|\([^)]*\):) ]]; then
                  FIRST_KEYWORD="${BASH_REMATCH[1]}"
                  case "$FIRST_KEYWORD" in
                    feat)
                      [[ "$BUMP" != "major" ]] && BUMP="minor"
                      ;;
                    fix|docs|style|refactor|perf|test|chore|build|ci)
                      [[ "$BUMP" != "major" && "$BUMP" != "minor" ]] && BUMP="patch"
                      ;;
                    revert)
                      [[ "$BUMP" != "major" && "$BUMP" != "minor" ]] && BUMP="patch"
                      ;;
                  esac
                fi
              done <<< "$COMMITS"
              
              if [ -z "$BUMP" ]; then
                echo "No valid semantic keyword found. Skipping release."
                echo "tag=" >> "$GITHUB_OUTPUT"
                echo "version=" >> "$GITHUB_OUTPUT"
                exit 0
              fi
              ;;
            "major")
              BUMP="major"
              ;;
            "minor")
              BUMP="minor"
              ;;
            "patch")
              BUMP="patch"
              ;;
            *)
              echo "Error: Invalid version-bump value '${{ inputs.version-bump }}'"
              exit 1
              ;;
          esac
          
          # Calculate new version
          case $BUMP in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          NEW_TAG="v$NEW_VERSION"
        fi
        
        # Generate CHANGELOG
        # Use the already fetched latest tag for changelog reference
        PREV_TAG="${LATEST_TAG:-initial commit}"
        REPO_URL="https://github.com/${{ github.repository }}"
        RELEASE_DATE=$(date -u +"%B %d, %Y")
        GIT_HASH=$(git rev-parse --short HEAD)
        
        # Create changelog content
        echo "## $NEW_TAG" > changelog.md
        echo "" >> changelog.md
        echo "**Release Date**: $RELEASE_DATE" >> changelog.md
        echo "**Commit**: \`$GIT_HASH\`" >> changelog.md
        echo "**Previous Version**: \`$PREV_TAG\`" >> changelog.md
        echo "" >> changelog.md
        echo "### Changes" >> changelog.md
        
        # Get commits since last tag
        if [ -n "$RANGE" ]; then
          COMMITS=$(git log $RANGE --pretty=format:"- %s (%h)" --reverse)
          if [ -n "$COMMITS" ]; then
            echo "" >> changelog.md
            echo "$COMMITS" >> changelog.md
          fi
        fi
        
        # Add full changelog link
        if [ -n "$LATEST_TAG" ]; then
          echo "" >> changelog.md
          echo "**Full Changelog**: [$NEW_TAG ... $PREV_TAG]($REPO_URL/compare/$LATEST_TAG...$NEW_TAG)" >> changelog.md
        fi
        
        # Add additional release notes if provided (limit to 512 chars)
        if [ -n "${{ inputs.release-notes }}" ]; then
          RELEASE_NOTES="${{ inputs.release-notes }}"
          if [ ${#RELEASE_NOTES} -gt 512 ]; then
            echo "Warning: Release notes truncated to 512 characters"
            RELEASE_NOTES="${RELEASE_NOTES:0:512}..."
          fi
          echo "" >> changelog.md
          echo "### Additional Notes" >> changelog.md
          echo "" >> changelog.md
          echo "$RELEASE_NOTES" >> changelog.md
        fi
        
        # Check total changelog length (limit to 1024 chars)
        CHANGELOG_CONTENT=$(cat changelog.md)
        if [ ${#CHANGELOG_CONTENT} -gt 1024 ]; then
          echo "Warning: Total changelog content exceeds 1024 characters"
          # Truncate the changelog content
          head -c 1024 changelog.md > changelog_temp.md
          echo "..." >> changelog_temp.md
          mv changelog_temp.md changelog.md
        fi
        
        # Create git tag
        git tag "$NEW_TAG"
        git push origin "$NEW_TAG"
        
        # Create GitHub release
        RELEASE_ARGS=("$NEW_TAG" "--title" "Release $NEW_TAG" "--notes-file" "changelog.md")
        
        # Add draft flag if specified
        if [ "${{ inputs.draft }}" = "true" ]; then
          RELEASE_ARGS+=("--draft")
        fi
        
        # Add prerelease flag if specified (works with or without draft)
        if [ "${{ inputs.prerelease }}" = "true" ]; then
          RELEASE_ARGS+=("--prerelease")
        fi
        
        # Create release using GitHub CLI
        gh release create "${RELEASE_ARGS[@]}"
        
        # Set outputs
        echo "tag=$NEW_TAG" >> "$GITHUB_OUTPUT"
        echo "version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
        
        echo "Created release: $NEW_TAG"
        echo "Version: $NEW_VERSION" 